{"ts":1355163728781,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"require 'tower'\nknox  = require('knox')\nspawn = require('child_process').spawn\nwhich = require('which').sync\npath  = require('path')\n\nspawnGrunt = (args = []) ->\n  args.push('--config', path.join(process.cwd(), 'grunt.coffee'))\n\n  grunt   = which('grunt')\n  watcher = spawn(grunt, args) \n  watcher.stdout.setEncoding('utf8')\n  watcher.stderr.setEncoding('utf8')\n  watcher.stdout.on 'data', (data) ->\n    console.log data.replace(/\\n$/m, '') # remove extra line\n  watcher.stderr.on 'data', (data) ->\n    console.log data.replace(/\\n$/m, '')\n\n# Watches and compiles assets to ./public\ntask 'watch', ->\n  spawnGrunt ['start']\n\n# Compiles assets to ./public (see `task 'watch'` for persistent compilation)\ntask 'build', ->\n  spawnGrunt()\n\n# This uploads all of your assets\ntask 'assets:upload', ->\n  invoke 'assets:upload:s3'\n\n# This uploads all of your assets to Amazon Web Services S3\ntask 'assets:upload:s3', ->\n  invoke 'environment'\n\n  # Create a client from your S3 credentials\n  client  = knox.createClient Tower.config.credentials.s3\n\n  # Start uploading each asset\n  Tower.ApplicationAssets.upload (from, to, headers, callback) ->\n    client.putFile from, to, headers, callback\n\n# This bundles all of your assets into neat little files\ntask 'assets:bundle', ->\n  invoke 'environment'\n  Tower.ApplicationAssets.bundle(minify: false)\n\n# This task displays the sizes of the assets on the current project\ntask 'assets:stats', 'Table displaying uncompressed, minified, and gzipped asset sizes', ->\n  invoke 'environment'\n  Tower.ApplicationAssets.stats()\n\n# This runs the seed file, which initializes your db with data\ntask 'db:seed', ->\n  App = require('tower').Application.instance()\n  App.initialize =>\n    require './data/seeds'\n\ntask 'db:drop', ->\n  App = require('tower').Application.instance()\n  App.initialize =>\n    Tower.StoreMongodb.clean()\n    process.nextTick(process.exit)\n\n# This puts your Tower app in production mode, used for special tasks\ntask 'environment', ->\n  Tower.env = 'production'\n  # This initializes your Tower application, used for special taks\n  Tower.Application.instance().initialize()\n\n# This displays all of the routes for your Tower app\ntask 'routes', ->\n  invoke 'environment'\n\n  result  = []\n  routes  = Tower.Route.all()\n\n  methods =\n    GET:    'GET'\n    POST:   'POST'\n    PUT:    'PUT'\n    DELETE: 'DELETE'\n\n  rows  = []\n  max   = [0, 0, 0, 0]\n\n  # @todo build an ascii table without any borders\n  routes.forEach (route, i) ->\n    route.options.to ||= _.camelize(route.controller.name, true).replace(/Controller$/, '') + \"##{route.controller.action}\"\n    row = []\n\n    method = methods[route.methods[0].toUpperCase()]\n    routePath = route.path.replace('.:format?', '')\n\n    row.push method\n    row.push routePath\n    row.push route.options.to\n    row.push \"curl -X #{method} http://localhost:3000#{routePath}.json\"\n\n    max.forEach (value, j) ->\n      max[j] = Math.max(value, row[j].length)\n\n    rows.push(row)\n\n  rows.forEach (row, i) ->\n    row.forEach (column, j) ->\n      row[j] = column + _.repeat(' ', max[j] - column.length + 4)\n\n    rows[i] = row.join('')\n\n  process.exit()\n\ntask 'jobs', ->\n  # make sure tower is loaded so we can get models\n  # invoke 'environment'\n  # needs to be the same as the current running app (local or remote)\n  Tower.env = process.env.ENV || 'development'\n  \n  Tower.Application.instance().initialize =>\n    process.nextTick =>\n      kue   = require('kue')\n      jobs  = kue.createQueue()\n\n      run = (job, done) =>\n        data    = job.data\n        klass   = Tower.constant(data.klass)\n        method  = data.method\n        args    = data.args || []\n        args.push(done) if data.async\n        klass[method].apply(klass, args)\n        done() unless data.async # if it's not async then just callback immediately\n\n      jobs.types (error, types) =>\n        throw error if error\n        atOnce = 2 # @todo configurable\n        for type in types\n          jobs.process(type, atOnce, run)\n"]],"start1":0,"start2":0,"length1":0,"length2":3969}]],"length":3969}
